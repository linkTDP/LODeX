<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: black;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

/********************
 * TOOLTIP CSS
 */

.nvtooltip {
  position: absolute;
  background-color: rgba(255,255,255,1);
  padding: 10px;
  border: 1px solid #ddd;

  font-family: Arial;
  font-size: 13px;

  transition: opacity 500ms linear;
  -moz-transition: opacity 500ms linear;
  -webkit-transition: opacity 500ms linear;

  transition-delay: 500ms
  -moz-transition-delay: 500ms;
  -webkit-transition-delay: 500ms;

  -moz-box-shadow: 4px 4px 12px rgba(0,0,0,.5);
  -webkit-box-shadow: 4px 4px 12px rgba(0,0,0,.5);
  box-shadow: 4px 4px 12px rgba(0,0,0,.5);

  -moz-border-radius: 15px;
  border-radius: 15px;
}

.nvtooltip h3 {
  margin: 0;
  padding: 0;
  text-align: center;
}

.nvtooltip p {
  margin: 0;
  padding: 0;
  text-align: center;
}

.nvtooltip span {
  display: inline-block;
  margin: 2px 0;
}

</style>
<body>
	
	<script src="http://d3js.org/d3.v3.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<div id="chart"></div>
    <link href='http://fonts.googleapis.com/css?family=Cinzel:400,700' rel='stylesheet' type='text/css'>
<script>
// (function($) {

// 	  var nvtooltip = window.nvtooltip = {};

// 	  nvtooltip.show = function(pos, content, gravity, dist) {
// 	    var container = $('<div class="nvtooltip">');

// 	    gravity = gravity || 's';
// 	    dist = dist || 20;

// 	    container
// 	      .html(content)
// 	      .css({left: -1000, top: -1000, opacity: 0})
// 	      .appendTo('body');

// 	    var height = container.height() + parseInt(container.css('padding-top'))  + parseInt(container.css('padding-bottom')),
// 	        width = container.width() + parseInt(container.css('padding-left'))  + parseInt(container.css('padding-right')),
// 	        windowWidth = $(window).width(),
// 	        windowHeight = $(window).height(),
// 	        scrollTop = $('body').scrollTop(),  //TODO: also adjust horizontal scroll
// 	        left, top;


// 	    //TODO: implement other gravities
// 	    switch (gravity) {
// 	      case 'e':
// 	      case 'w':
// 	      case 'n':
// 	        left = pos[0] - (width / 2);
// 	        top = pos[1] + dist;
// 	        if (left < 0) left = 5;
// 	        if (left + width > windowWidth) left = windowWidth - width - 5;
// 	        if (scrollTop + windowHeight < top + height) top = pos[1] - height - dist;
// 	        break;
// 	      case 's':
// 	        left = pos[0] - (width / 2);
// 	        top = pos[1] - height - dist;
// 	        if (left < 0) left = 5;
// 	        if (left + width > windowWidth) left = windowWidth - width - 5;
// 	        if (scrollTop > top) top = pos[1] + dist;
// 	        break;
// 	    }

// 	    container
// 	        .css({
// 	          left: left,
// 	          top: top,
// 	          opacity: 1
// 	        });
// 	  };

// 	  nvtooltip.cleanup = function() {
// 	    var tooltips = $('.nvtooltip');

// 	    // remove right away, but delay the show with css
// 	    tooltips.css({
// 	        'transition-delay': '0 !important',
// 	        '-moz-transition-delay': '0 !important',
// 	        '-webkit-transition-delay': '0 !important'
// 	    });

// 	    tooltips.css('opacity',0);

// 	    setTimeout(function() {
// 	      tooltips.remove()
// 	    }, 500);
// 	  };

// 	})(jQuery);


var margin = {top: 20, right: 20, bottom: 30, left: 40}
	var width = document.documentElement.clientWidth - margin.left - margin.right;
	var height = document.documentElement.clientHeight - margin.top - margin.bottom;
	var fill = d3.scale.category20();
	var stroke_width = 1.5;
	var offset_x = 10;
	var offset_y = 12;
	var color = d3.scale.category20();	
	var tick = false;
	var div = d3.select("body").append("div")   
    .attr("class", "tooltip")
    .style("position", "absolute")
	 .style("top", 5)
	 .style("left",5)
// 	 .style("z-index",-1)
    .style("opacity", 1);
// 	var tooltip = d3.select("body")
// 	.append("div")
// 	.style("position", "absolute")
// 	.style("z-index", "10")
// 	.style("visibility", "hidden")
// 	.text(function(d) {return d.att});
// 	 var tip = d3.tip()
// 	  .attr('class', 'd3-tip')
// 	  .offset([-10, 0])
// 	  .html(function(d) {
// 	    return "<strong>Frequency:</strong> <span style='color:red'>" + d.ni + "</span>";
// 	  }); 
	
	var svg = d3.select("#chart")
	.append("svg:svg")
	    .attr("width", width)
	    .attr("height", height)
	    .attr("pointer-events", "all")
    .append('svg:g')
		//.call(d3.behavior.zoom().on("zoom", redraw)) //bug quando viene chiamat la funzione tick, si scatena anche redraw
	.append('svg:g');
	
	svg.append('svg:rect')
    .attr('width', width)
    .attr('height', height)
    .attr('fill', 'white');
    
    function redraw() {
    	console.log("redraw");
    	if(tick){
    		tick = false;
    		return;
    	}
    		
	  //console.log("here", d3.event.translate, d3.event.scale);
	  svg.attr("transform",
	      "translate(" + d3.event.translate + ")"
	      + " scale(" + d3.event.scale + ")");
	}
    
    
		
	d3.json("/getData/{{endpoint_id}}", function(error, graph) {
//		var draw = function(graph){
		console.table(graph.nodes);
		var vocab=graph.vocab;
		for (a in vocab){
			color(vocab[a]);
		}
		console.log(vocab[0]);
		var max_ni = graph.nodes[0].ni;
		var max_np = graph.links[0].np;
		for(i = 1; i < graph.nodes.length; i++){
			if(graph.nodes[i].ni > max_ni)
				max_ni = graph.nodes[i].ni;
		}
		//console.log(min_ni);
		//console.log(max_ni);
		for(i = 1; i < graph.links.length; i++){
			if(graph.links[i].np > max_np)
				max_np = graph.links[i].np;
		}
		console.log(max_np);
		console.log((2500) * 31 / graph.nodes.length);
		console.log(graph.nodes.length);
		//debugger;	
		var charge = (-3800) * 31 / graph.nodes.length;
	
		  var force = d3.layout.force()
		      .nodes(graph.nodes)
		      .links(graph.links)
		      .gravity(1).linkDistance(80)
		      .charge(charge)
		      .size([width, height])
		      .start();
		      
		      /**
		       * seleziona tutti gli elementi che hanno la classe link, se non esistono vengono creati
		       *  uno per ogni elemento nell'array di dati che viene passato a data.
		       * Tutti gli elementi sono svg di tipo linea, specificato nel metodo append()
		       * il metodo style setta lo spessore della linea, che viene calcolato in base al numero di propriet√†.
		       */
		  var link = svg.selectAll("line.link")
		      .data(graph.links)
		      .enter().append("svg:line") //
		      .attr("class", "link")
		      .attr("id",function(d,i) {return 'edge'+i})
		      .attr('marker-end','url(#arrowhead)')
		      .style("stroke-width", function(d) { return (d.np * 10 / max_np) + 1;; })
		      .attr("x1", function(d) { return d.source.x; })
			  .attr("y1", function(d) { return d.source.y; })
		  	  .attr("x2", function(d) { return d.target.x; })
		  	  .attr("y2", function(d) { return d.target.y; });
		
		  var node = svg.selectAll("circle.node")
		      .data(graph.nodes)
		      .enter().append("svg:circle")
		      .attr("class", "node")
		      .attr("cx", function(d) { return d.x; })
		  	  .attr("cy", function(d) { return d.y; })
		      .attr("r", function(d) { return (d.ni * 25 / max_ni)+5; }) //dimensione nodi
		      .style("fill", function(d) { return color(d.vocab); })
		      .call(force.drag)
		      .on("mouseover", function(d) {      
	            div.transition()        
	                .duration(10000)      
	                .style('border','1px solid black');
	            s="<table>";
	//             console.log(d.att)
	            for (var j = 0; j < d.att.length; j++){
	            	s+="<tr>";
	            	s+="<td>";
	            	s+='<svg width="8" height="8"> <rect width="8" height="8" style="fill:'+color(d.att[j].vocab)+';" /></svg>';
	//             	console.log('<svg width="10" height="10"> <rect width="10" height="10" style="fill:'+d.att[j].vocab+';" /></svg>')
	            	s+= d.att[j].p;
	            	s+="</td>";
	            	s+="<td>";
	            	s+=d.att[j].n;
	            	s+="</td>";
	            	s += "</tr>";
	            	console.log(color(d.att[j].vocab));
	            }
	            s+="</table>";
	            
	             
	            div.html(s)  
	                .style("left", "5px" )    //(d3.event.pageX)
	                 .style("bottom", "5px" )
	                  .style("font-family","Cinzel, serif")
	                  .style("font-size", "15px")
	                  .style("font-weight",600);    
	            })
	//             legend.append("rect")
	//   .attr("x", width - 18)
	//   .attr("width", 18)
	//   .attr("height", 18)
	//       .style("fill", color);
	            
	        .on("mouseout", function(d) {       
	            div.transition()        
	                .duration(500)      
	                .style("opacity", 0);   
	        });
		     
		  
	//	      .on("mouseover", function(d){return tooltip.style("visibility", "visible");})
	//		  .on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
	//		  .on("mouseout", function(){return tooltip.style("visibility", "hidden");})
		      
			var label = svg.selectAll(".label")
			  .data(graph.nodes)
			  .enter()                       
			  .append("text")
			  .attr("class", "label")
			  .attr("x", function(d) { return d.x + (d.ni * 25 / max_ni) + 5  + stroke_width; })
			  .attr("y", function(d) { return d.y; })
			  .text( function (d) { return d.name; })
			  .attr("font-family", "sans-serif")
			  .attr("font-size", "10px")
			  .attr("fill", "black");
			/*var weight = svg.selectAll(".weight")
			  .data(graph.nodes)
			  .enter()                       
			  .append("text")
			  .attr("class", "weight")
			  .text( function (d) { return "weight: " + d.weight; })
			  .attr("font-family", "sans-serif")
			  .attr("font-size", "10px")
			  .attr("fill", "black");*/
			  
			node.append("title")
				.text(function(d) { return d.name; });
			link.append("title")
				.text(function(d) { return d.name; });
				
			svg.style("opacity", 1e-6)
			.transition()
		  	.duration(1000)
		  	.style("opacity", 1);
			/**
			 * quando viene chiamata la funziona tick vengono ricalcolate le coordinate x e y.
			 */
			force.on("tick", function() {
				tick = true;
				console.log("tick");
			    link.attr("x1", function(d) { return d.source.x; })
			        .attr("y1", function(d) { return d.source.y; })
			        .attr("x2", function(d) { return d.target.x; })
			        .attr("y2", function(d) { return d.target.y; });
			
			    node.attr("cx", function(d) { return d.x; })
					.attr("cy", function(d) { return d.y; });
			        
			    label.attr("x", function(d) { return d.x + (d.ni * 25 / max_ni) + 5  + stroke_width; })
					 .attr("y", function(d) { return d.y; });
					
				/*weight.attr("x", function(d) { return d.x + d.weight + offset_x + stroke_width; })
				.attr("y", function(d) { return d.y + offset_y; });*/
	  });
	//};
	
	// draw legend
  var legend = svg.selectAll(".legend")
      .data(color.domain())
    .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

  // draw legend colored rectangles
  legend.append("rect")
  .attr("x", width - 18)
  .attr("width", 18)
  .attr("height", 18)
      .style("fill", color);

  // draw legend text
  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-family","Cinzel")
      .text(function(d) { return d;});
	});
	
	
</script>
</body>
